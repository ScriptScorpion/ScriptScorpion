C++ учебный материал:
https://www.learncpp.com/
https://cppreference.com/

C++ практика:
https://www.freecodecamp.org/news/learn-programming-in-cpp/
https://leetcode.com/

Полезные советы: Pointers - чтобы узнать адрес твоего значения в памяти поставь & перед тем что ты хочешь узнать, а если хочешь узнать что находиться что находиться под каким-то адресом поставь * перед переменной которая станет указателем(пример работает если b тоже int: int *a=&b). НО & может использоваться как указатель отличие только в том что его не надо потом преобразовывать и еще одно отличие это что он не может указывать на nullptr. Лучшая практика использовать *(указатель) тогда когда значение может быть null, а &(ссылку) когда значение не может быть null. Если изменить указатель то измениться переменная на которую он указывал. Если увидишь больше 1-ой "*" в переменной которая указатель, это значит что она указывает на другой указатель.

unsigned - не может быть негативным(меньше нуля).

signed - может быть негативным и положительным.

`std::ifstream "имя файла"` - для чтения файла.

`std::ofstream "имя файла"` - для записи файла, если таково файла нету он создаст.

`std::fstream "имя файла"` - для записи и чтения файла, (не рекомендую пользоваться этим) не создаст новый файл если таково нету.

`static "тип переменной" "имя"` - static делает так что переменная сохраняет своё значение до конца самой программы. Переменные объявленные как static их нельзя использовать в других файлах, только в текущем файле. переменный static МОЖНО изменять.

`class "имя"` - class это похожее на struct, но в class можно указывать что ты можешь доставать из него а что останется только в нём. вобщем sturct по стандарту там все переменные public, а в class по стандарту там все переменные private.использование "class" более предпочтительно по сравнению с struct в C++ из за большего количества полезных свойств. пример кода как сделать class и struct и потом вызвать их:
```cpp
class Guard {
    public:
        std::string name;
};
struct Obj {
    std::string name;
};
int main() {
    Guard person;
    Obj myobject;
    person.name = "Guard";
    myobject.name = "Object";
}
```

`static_cast<"тип данных на который изменить"> ("переменная с любым значением")` - это преобразует в тот тип данных который ты указал используя "<>". пример:
```cpp
char c = 'a';  
// Converting from char to int
int i = static_cast<int>(c);
```

`enum class "имя класса" {"Константы"}` - это создаст множество переменных, которые можно вызвать как в class или struct но указать надо изначальное значение из "Констант" которые введены, всем переменным которые названы "Константы" (как ты их назвал), им присваивается по умолчанию значение от 1, до их количества, значение переменных можно указать через знак "=". Enum подходит только для содержания значений которым можно присвоить имя, они значимы и надо знать что за что отвечает. Пример enum:
```cpp
enum Color { Red = 1, Green = 2, Blue = 3 };
Color c = Red; // хранит 1

/* Или */

enum class Color { Red = 1, Green = 2, Blue = 3 };
Color c = Color::Red; //хранит Red но если сделать static_cast<int> будет 1
```

`template <typename T>`  - Шаблоны позволяют создавать универсальные функции и классы, работающие с разными типами данных без необходимости их переписывания для каждого конкретного типа.

constexpr vs const - разницы в том что const вычисляеться на этапе runtime а constexpr вычисляеться во время компиляции, constexpr восновном нужен только для оптимизаций кода.
Норм ответ с StackOverflow:
"const applies for variables, and prevents them from being modified in your code. constexpr tells the compiler that this expression results in a compile time constant value, so it can be used in places like array lengths, assigning to const variables."

`(тип данных) переменная` - это говорит компилятору чтобы он рассматривал переменную как "тип данных" даже если переменная не равна типу данных который надо. пример:
 ```cpp
int a = 70;
std::cout << (char) a; // F
```

new - создает объекты в куче, одновременно выделяет память и вызывает конструктор.
malloc -  просто выделяет необработанную память(возвращает void* по стандарту).

если в C++ сделать массив и передать в него переменную в которой число а потом изменить значение этой переменной то массив не уменьшиться, так как массив использует самое первое значение которое было у этой переменной(но если будет указатель но переменную то может измениться значение, но в массивах нельзя сделать указатель).Пример:

```cpp
size_t size = 5;
char array[size];
size = 10;
// array will have the same size
```
header файлы в C++ нужны для того чтобы писать функции или классы в любом месте программы(иногда в них пишут даже логику но это редко).
