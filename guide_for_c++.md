C++ учебный материал:
https://www.learncpp.com/
https://cppreference.com/
https://isocpp.org/

C++ практика:
https://www.freecodecamp.org/news/learn-programming-in-cpp/
https://leetcode.com/

Полезные советы: 
Pointers - чтобы узнать адрес твоего значения в памяти поставь & перед тем что ты хочешь узнать, а если хочешь узнать что находиться что находиться под каким-то адресом поставь * перед переменной которая станет указателем(пример работает если b тоже int: int *a=&b). НО & может использоваться как указатель отличие только в том что его не надо потом преобразовывать и еще одно отличие это что он не может указывать на nullptr. Лучшая практика использовать *(указатель) тогда когда значение может быть null, а &(ссылку) когда значение не может быть null. Если изменить указатель то измениться переменная на которую он указывал. Если увидишь больше 1-ой "*" в переменной которая указатель, это значит что она указывает на другой указатель.

decimal value: no prefix
binary value: 0b prefix
hex value: 0x prefix

unsigned - не может быть негативным(меньше нуля).

signed - может быть негативным и положительным.

частая ошибка новичков что если делать `std::string test = ''` вызовет ошибку, а `std::string test = ""` не вызовет ошибку - это потому что в первом случаи ты присваиваешь строке test ничего, а во втором случаи ты присваеваешь строке test символ '\0'(конец строки). 

`std::ifstream "имя файла"` - для чтения файла.

`std::ofstream "имя файла"` - для записи файла, если таково файла нету он создаст.

`std::fstream "имя файла"` - для записи и чтения файла, (не рекомендую пользоваться этим) не создаст новый файл если таково нету.

`static "тип переменной" "имя"` - static делает так что переменная сохраняет своё значение до конца самой программы. Переменные объявленные как static их нельзя использовать в других файлах, только в текущем файле. переменный static МОЖНО изменять.

`class "имя"` - class это похожее на struct, но в class можно указывать что ты можешь доставать из него а что останется только в нём. вобщем sturct по стандарту там все переменные public, а в class по стандарту там все переменные private.использование "class" более предпочтительно по сравнению с struct в C++ из за большего количества полезных свойств. пример кода как сделать class и struct и потом вызвать их:
```cpp
class Guard {
    public:
        std::string name;
};
struct Obj {
    std::string name;
};
int main() {
    Guard person;
    Obj myobject;
    person.name = "Guard";
    myobject.name = "Object";
}
```

`static_cast<"тип данных на который изменить"> ("переменная с любым значением")` - это преобразует в тот тип данных который ты указал используя "<>". пример:
```cpp
char c = 'a';  
// Converting from char to int
int i = static_cast<int>(c);
```

`enum class "имя класса" {"Константы"}` - это создаст множество переменных, которые можно вызвать как в class или struct но указать надо изначальное значение из "Констант" которые введены, всем переменным которые названы "Константы" (как ты их назвал), им присваивается по умолчанию значение от 1, до их количества, значение переменных можно указать через знак "=". Enum подходит только для содержания значений которым можно присвоить имя, они значимы и надо знать что за что отвечает. Пример enum:
```cpp
enum Color { Red = 1, Green = 2, Blue = 3 };
Color c = Red; // хранит 1

/* Или */

enum class Color { Red = 1, Green = 2, Blue = 3 };
Color c = Color::Red; //хранит Red но если сделать static_cast<int> будет 1
```

`template <typename T>`  - Шаблоны позволяют создавать универсальные функции и классы, работающие с разными типами данных без необходимости их переписывания для каждого конкретного типа.

что значит `<` или `>` в строкавых случаях: представим что переменные `a` и `b` они строки и в C++ если сделать `if (a < b)` это будет работать - это будет проверять правда ли первая буква переменной `a` по алфавиту находиться левее первой буквы переменной `b`, для случая с `>` будет проверить находиться ли буква правее другой буквы.

constexpr vs const - разницы в том что const вычисляеться на этапе runtime а constexpr вычисляеться во время компиляции, constexpr восновном нужен только для оптимизаций кода.
Норм ответ с StackOverflow:
"const applies for variables, and prevents them from being modified in your code. constexpr tells the compiler that this expression results in a compile time constant value, so it can be used in places like array lengths, assigning to const variables."

`(тип данных) переменная` - это говорит компилятору чтобы он рассматривал переменную как "тип данных" даже если переменная не равна типу данных который надо. пример:
 ```cpp
int a = 70;
std::cout << (char) a; // F
```

new - создает объекты в куче, одновременно выделяет память и вызывает конструктор.
malloc -  просто выделяет необработанную память(возвращает void* по стандарту).

если в C++ сделать массив и передать в него переменную в которой число а потом изменить значение этой переменной то массив не уменьшиться, так как массив использует самое первое значение которое было у этой переменной(но если будет указатель но переменную то может измениться значение, но в массивах нельзя сделать указатель).Пример:

```cpp
size_t size = 5;
char array[size];
size = 10;
// array will have the same size
```

header файлы в C++ нужны для того чтобы писать функции или классы в любом месте программы(иногда в них пишут даже логику но это редко).

`<` и `!=` если поставить их в цикле они работают одинаково.

если массив динамический и надо вывести его полное содержимое, надо сделать `std::cout << (char*)array;` но если делать `std::cout << *array;` выведет только первое значение из массива `array`

различие между `private` и `protected` в том что `private` - может использоваться только для этого класса или структуры(если попытаться обратитьтся к полям из private после наследования будет ошибка), `protected` - может также использоваться в других классах или структурах с помошью наследования.

https://en.wikipedia.org/wiki/Bitwise_operations_in_C

condition part в C++(for(initialization_part; condition_part; do_with_initialized_variable_part)) работает также как и в if ну типо можно сделать && и || и это будет работать

код чтобы определить версию твоего компилятора g++/gcc:
```cpp
#include <iostream>
int main() {
    long cpp_version = __cplusplus;

    if (cpp_version == 199711L) {
        std::cout << "C++98/03" << std::endl;
    } else if (cpp_version == 201103L) {
        std::cout << "C++11" << std::endl;
    } else if (cpp_version == 201402L) {
        std::cout << "C++14" << std::endl;
    } else if (cpp_version == 201703L) {
        std::cout << "C++17" << std::endl;
    } else if (cpp_version == 202002L) {
        std::cout << "C++20" << std::endl;
    } else if (cpp_version > 202002L) {
        std::cout << "C++23 or later (value: " << cpp_version << ")" << std::endl;
    } else {
        std::cout << "Unknown C++ standard (value: " << cpp_version << ")" << std::endl;
    }
}
```
```c
#include <stdio.h>
int main() {
    #if defined(STDC_VERSION)
     long version = STDC_VERSION;
     if (version == 0L) {   printf("C89/C90  (ANSI C)");
     } else if (version == 199409L) {
         printf("C94/C95 (Amendment 1)");
     } else if (version == 199901L) {
         printf("C99");
     } else if (version == 201112L) {
         printf("C11");
     } else if (version == 201710L) {
         printf("C17");
     } else if (version == 202311L) {
         printf("C23");
     } else {
         printf("Unknown standard");
     }
 #endif
}
```

`std::byte` - в C++ может хранить в себе число-символные значения 0-255 в числах и символы 0-255 по ASCII, и чтобы положить значение в переменную с типом `std::byte` можно сделать: `std::byte a = {100};` или `std::byte a = std::byte(100);` а чтобы получить значение из переменной типа `std::byte` надо её преобразовать в другой тип данных используя `static_cast` или используя `(тип данных)a`.

`reinterpret_cast <тип данных> (&переменная)` - это скажет компилятору чтобы он преобразовал значение по адрессу переменной в значение типа данных который указан, это говорит компилятору: "смотри на эти биты как на символы/указатель/другой тип".
пример:
```cpp
#include <iostream>
int main() {
    int example = 0x6E7566; // we going backwards: 66 - f, 75 - u, 6E - n. 
    char* str = reinterpret_cast <char*> (&example); // we converting value inside adress of 'example' variable to a characters 
    std::cout << str; // will print 'fun'
    str = nullptr;
    free(str);
    return 0;
}
```

отличия `std::string` от `std::string_view` в том что `std::string` динамически хранит строку, а `std::string_view` просто указывает на ячейку со строкой НО ЭТО НЕ УКАЗАТЕЛЬ(НЕЛЬЗЯ МЕНЯТЬ ЗНАЧЕНИЕ `std::string_view` ЭТО МОЖЕТ ПРИВЕСТИ К НЕИЗВЕСТНОМУ ПОВЕДЕНИЮ)

чтобы скомпилировать два или больше файлов в C++, надо: в одном файле указать имя и тело функции(пример: `void function();`) и в другом файле надо дополнить её(пример: `void function() {std::cout << "Example";}`), а потом просто скомпилировать два файла с помошью `g++` указав два файла.

разница между rvalue(&&) и lvalue(&): в том что rvalue требует именно значение а не переменную, а lvalue требует именно переменную а не значение. Вот пример:
```cpp
#include <iostream>
void rval(int&& val) {
    val = 50;
    std::cout << val << '\n';
}
void lval(int& val) {
    val = 60;
    std::cout << val << '\n';
}
int main() {
    int a = 30;
    rval(30); // this will be rvalue
    std::cout <<"a = " << a << std::endl;
    lval(a); // this will be lvalue
    std::cout << "a = " << a << std::endl;
    return 0;
}
```

слово `this` - в C++ оно даёт все переменные класса или структуры (переменные функций не берутся в учёт). Чтобы узнать именно определенную переменную можно сделать `this->имя_переменной`, это удобны когда у тебя переменная функции имеют такоеже имя как и переменная в классе или структуре.
